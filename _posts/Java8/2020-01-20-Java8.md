---
layout: page-fullwidth
subheadline: Java8新特性：Lambda、方法引用、Stream流
title: "Java8新特性：Lambda、方法引用、Stream流"
meta_teaser: "Java8新特性：Lambda、方法引用、Stream流"
teaser: "<em>Java8新特性</em>Lambda、方法引用、Stream流。"
header:
    image: homepage_typography.jpg
    background-color: "#262930"
    caption: 知乎链接
    caption_url: https://zhuanlan.zhihu.com/p/103593275
image:
    thumb:  homepage_typography-thumb.jpg
    homepage: homepage_typography.jpg
    caption: Image by Antonio
    caption_url: "https://zhuanlan.zhihu.com/p/103593275"
categories:
    - design
    - typography
---
<!--more-->

<div class="row">
<div class="medium-4 medium-push-8 columns" markdown="1">
<div class="panel radius" markdown="1">
**目录**
{: #toc }
*  TOC
{:toc}
</div>
</div><!-- /.medium-4.columns -->

<div class="medium-8 medium-pull-4 columns" markdown="1">
#### Java 8 函数式接口

函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。

函数式接口可以被隐式转换为 lambda 表达式。

Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。

函数式接口可以对现有的函数友好地支持 lambda。

JDK 1.8 之前已有的函数式接口:

- java.lang.Runnable
- java.util.concurrent.Callable
- java.security.PrivilegedAction
- java.util.Comparator
- java.io.FileFilter
- java.nio.file.PathMatcher
- java.lang.reflect.InvocationHandler
- java.beans.PropertyChangeListener
- java.awt.event.ActionListener
- javax.swing.event.ChangeListener

JDK 1.8 新增加的函数接口：

- java.util.function

java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：

| 序号 | 接口 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **BiConsumer**代表了一个接受两个输入参数的操作，并且不返回任何结果 |
| 2    | **BiFunction**代表了一个接受两个输入参数的方法，并且返回一个结果 |
| 3    | **BinaryOperator**代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 |
| 4    | **BiPredicate**代表了一个两个参数的boolean值方法             |
| 5    | **BooleanSupplier**代表了boolean值结果的提供方               |
| 6    | **Consumer**代表了接受一个输入参数并且无返回的操作           |
| 7    | **DoubleBinaryOperator**代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 |
| 8    | **DoubleConsumer**代表一个接受double值参数的操作，并且不返回结果。 |
| 9    | **DoubleFunction**代表接受一个double值参数的方法，并且返回结果 |
| 10   | **DoublePredicate**代表一个拥有double值参数的boolean值方法   |
| 11   | **DoubleSupplier**代表一个double值结构的提供方               |
| 12   | **DoubleToIntFunction**接受一个double类型输入，返回一个int类型结果。 |
| 13   | **DoubleToLongFunction**接受一个double类型输入，返回一个long类型结果 |
| 14   | **DoubleUnaryOperator**接受一个参数同为类型double,返回值类型也为double 。 |
| 15   | **Function**接受一个输入参数，返回一个结果。                 |
| 16   | **IntBinaryOperator**接受两个参数同为类型int,返回值类型也为int 。 |
| 17   | **IntConsumer**接受一个int类型的输入参数，无返回值 。        |
| 18   | **IntFunction**接受一个int类型输入参数，返回一个结果 。      |
| 19   | **IntPredicate**：接受一个int输入参数，返回一个布尔值的结果。 |
| 20   | **IntSupplier**无参数，返回一个int类型结果。                 |
| 21   | **IntToDoubleFunction**接受一个int类型输入，返回一个double类型结果 。 |
| 22   | **IntToLongFunction**接受一个int类型输入，返回一个long类型结果。 |
| 23   | **IntUnaryOperator**接受一个参数同为类型int,返回值类型也为int 。 |
| 24   | **LongBinaryOperator**接受两个参数同为类型long,返回值类型也为long。 |
| 25   | **LongConsumer**接受一个long类型的输入参数，无返回值。       |
| 26   | **LongFunction**接受一个long类型输入参数，返回一个结果。     |
| 27   | **LongPredicate**R接受一个long输入参数，返回一个布尔值类型结果。 |
| 28   | **LongSupplier**无参数，返回一个结果long类型的值。           |
| 29   | **LongToDoubleFunction**接受一个long类型输入，返回一个double类型结果。 |
| 30   | **LongToIntFunction**接受一个long类型输入，返回一个int类型结果。 |
| 31   | **LongUnaryOperator**接受一个参数同为类型long,返回值类型也为long。 |
| 32   | **ObjDoubleConsumer**接受一个object类型和一个double类型的输入参数，无返回值。 |
| 33   | **ObjIntConsumer**接受一个object类型和一个int类型的输入参数，无返回值。 |
| 34   | **ObjLongConsumer**接受一个object类型和一个long类型的输入参数，无返回值。 |
| 35   | **Predicate**接受一个输入参数，返回一个布尔值结果。          |
| 36   | **Supplier**无参数，返回一个结果。                           |
| 37   | **ToDoubleBiFunction**接受两个输入参数，返回一个double类型结果 |
| 38   | **ToDoubleFunction**接受一个输入参数，返回一个double类型结果 |
| 39   | **ToIntBiFunction**接受两个输入参数，返回一个int类型结果。   |
| 40   | **ToIntFunction**接受一个输入参数，返回一个int类型结果。     |
| 41   | **ToLongBiFunction**接受两个输入参数，返回一个long类型结果。 |
| 42   | **ToLongFunction**接受一个输入参数，返回一个long类型结果。   |
| 43   | **UnaryOperator**接受一个参数为类型T,返回值类型也为T。       |

#### @FunctionInterface注解

使用@FunctionInterface的接口，该接口内只能有一个抽象方法(默认方法不限)，如果添加了多个抽象方法，编译器就会警告。

#### lambda表达式的基础语法

Java8中引入了一个新的操作符`->`,该操作符称之为箭头操作符或Lambda操作符。箭头操作符讲Lambda表达式拆分成两部分：

左侧：Lambda 表达式的参数列表

右侧：Lambda 表达式中所执行的功能，即lambda体

##### Lambda四种语法格式

- 语法格式一：无参数，无返回值  `() -> System.out.println("hello")`

```java
Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello World!");
            }
        };
        runnable.run();
		//使用lambda表达式
        Runnable runnable1 = () -> System.out.println("Hello Lambda!");
        runnable1.run();
```

- 语法格式二：无参数，有返回值。若实现方法体只有一行，return需省略。`Supplier<String> supplier = () -> "supplier".toUpperCase();`,还可以简写`Supplier<String> supplier = "supplier"::toUpperCase;`。

```java
Supplier<String> supplier = () -> {
    String str = "supplier";
   return str.toUpperCase();
};
System.out.println(supplier.get());
```

- 语法格式三：有一个参数，并且无返回值` (x) -> System.out.println(x)`；若参数只有一个参数，小括号可以不写；若lambda体中有多条语句，需要使用大括号{};

```java
Consumer<Integer> consumer = new Consumer<Integer>() {
            @Override
            public void accept(Integer num) {
                ++num;
                System.out.println(num);
            }
        };
        consumer.accept(10);
		//使用lambda表达式,(num),小括号可以省略
        IntConsumer consumer2 = (num) -> {
            ++num;
            System.out.println(num);
        };
        consumer2.accept(12);
```

- 语法格式四：有多个参数，有返回值，若lambda体中只有一条语句，return可以省略；参数列表的参数类型可以省略，JVM会根据上下文自动推断，即类型推断。

```java
Comparator<Integer> comparator = new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return Integer.compare(o1, o2);
        }
    };
    System.out.println(comparator.compare(1, 1));

    //使用lambda表达式
    Comparator<Integer> comparator1 = (x, y) -> Integer.compare(x, y);
    int compare = comparator1.compare(1, 2);
    System.out.println(compare);
```

#### Lambda四大核心接口

- 消费型接口Consumer<T>，有参数，没有返回值。可以对参数进行一些操作。

  ```java
  public interface Consumer<T> {
      void accept(T t);
  }
  ```

- 供给型接口Supplier<T>，无参数，有返回值。

  ```java
  public interface Supplier<T> {
      T get();
  }
  ```

- 函数式接口Function<T, R>，有参数，有返回值。

  ```java
  public interface Function<T, R> {
      R apply(T t);
  }
  ```

- 断言型接口，有参数，返回值是布尔值。

  ```java
  public interface Predicate<T> {
      boolean test(T t);
  }
  ```

### 方法引用

在Java 8之前只能进行值传递，方法是不能传递的。如果你想调用一个方法你必须先获取到它所在的类的实例，然后再通过实例去调用这个方法，但是Java 8新增了**方法引用**这个新特性可以让你直接把方法当做值来传递。

若Lambda体中的内容已经存在对应的方法实现，即存在一个方法，参数列表和返回值于函数是接口一致，方法的实现内容也和Lambda体中的内容相同。则可直接使用方法引用

如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。

因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样。

#### 方法引用的种类（Kinds of method references）

方法引用有很多种，它们的语法如下：

- 静态方法引用：`ClassName::methodName`
- 实例上的实例方法引用：`instanceReference::methodName`
- 超类上的实例方法引用：`super::methodName`
- 类型上的实例方法引用：`ClassName::methodName`
- 构造方法引用：`Class::new`。调用的构造方法是和函数式接口的参数类型一致的。
- 数组构造方法引用：`TypeName[]::new`

```java
// 静态方法引用：`ClassName::methodName`
Comparator<Integer> com1 = (x,y)->Integer.compare(x,y); //普通的lambda表达式
Comparator<Integer> com2 = Integer::compare; //lambda方法引用方式
int compare1 = com1.compare(1, 2);
int compare2 = com2.compare(1, 2);
System.out.println(compare1);
System.out.println(compare2);

// 实例上的实例方法引用：`instanceReference::methodName`
Employee employee = new Employee();
Supplier<Integer> sup1 = () -> employee.getAge();   //普通的lambda表达式
Supplier<Integer>  sup2  = employee::getAge;   //lambda方法引用方式
Integer age1 = sup1.get();
Integer age2 = sup2.get();
System.out.println(age1);
System.out.println(age2);

//类型上的实例方法引用：`ClassName::methodName`
BiPredicate<String, String> bp1 =(x,y)->x.equals(y);  //普通的lambda表达
BiPredicate<String, String> bp2 = String::equals;   //lambda方法引用方式
boolean test1 = bp1.test("哈哈", "哈哈");
boolean test2 = bp2.test("哈哈", "哈哈");
System.out.println(test1);
System.out.println(test2);

//构造方法引用：`Class::new`
Supplier<Employee> supplier1 = () -> new Employee();  //普通的lambda表达
Supplier<Employee> supplier2 = Employee::new; //lambda方法引用方式
Employee employee1 = supplier1.get();
Employee employee2 = supplier2.get();
System.out.println(employee1);
System.out.println(employee2);

// 数组构造方法引用：`TypeName[]::new`
Function<Integer,String[]> fun1 = (x) -> new String[x];
Function<Integer,String[]> fun2 = String[] :: new;
String[] str1 = fun1.apply(10);
String[] str2 = fun2.apply(20);
System.out.println(str1.length);
System.out.println(str2.length);
```

### Stream-流

#### 流Stream简单介绍

- Java8的两个重大改变，一个是Lambda表达式，另一个就是Stream API表达式。它可以让你以一种声明的方式处理数据。
- Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。
- 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等；元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。
- 流还天然的支持并行操作，也就不用去写复杂的多线程的代码。

#### Stream（流）主要概念

- **元素**是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。
- **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。
- **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。

和以前的Collection操作不同， Stream操作还有两个基础的特征：

- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。
- **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。

#### Stream抽象接口

```java
public interface Stream<T> extends BaseStream<T, Stream<T>> {
    Stream<T> filter(Predicate<? super T> var1);

    <R> Stream<R> map(Function<? super T, ? extends R> var1);

    IntStream mapToInt(ToIntFunction<? super T> var1);

    LongStream mapToLong(ToLongFunction<? super T> var1);

    DoubleStream mapToDouble(ToDoubleFunction<? super T> var1);

    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> var1);

    IntStream flatMapToInt(Function<? super T, ? extends IntStream> var1);

    LongStream flatMapToLong(Function<? super T, ? extends LongStream> var1);

    DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> var1);

    Stream<T> distinct();

    Stream<T> sorted();

    Stream<T> sorted(Comparator<? super T> var1);

    Stream<T> peek(Consumer<? super T> var1);

    Stream<T> limit(long var1);

    Stream<T> skip(long var1);

    void forEach(Consumer<? super T> var1);

    void forEachOrdered(Consumer<? super T> var1);

    Object[] toArray();

    <A> A[] toArray(IntFunction<A[]> var1);

    T reduce(T var1, BinaryOperator<T> var2);

    Optional<T> reduce(BinaryOperator<T> var1);

    <U> U reduce(U var1, BiFunction<U, ? super T, U> var2, BinaryOperator<U> var3);

    <R> R collect(Supplier<R> var1, BiConsumer<R, ? super T> var2, BiConsumer<R, R> var3);

    <R, A> R collect(Collector<? super T, A, R> var1);

    Optional<T> min(Comparator<? super T> var1);

    Optional<T> max(Comparator<? super T> var1);

    long count();

    boolean anyMatch(Predicate<? super T> var1);

    boolean allMatch(Predicate<? super T> var1);

    boolean noneMatch(Predicate<? super T> var1);

    Optional<T> findFirst();

    Optional<T> findAny();

    static <T> Stream.Builder<T> builder() {
        return new StreamBuilderImpl();
    }

    static <T> Stream<T> empty() {
        return StreamSupport.stream(Spliterators.emptySpliterator(), false);
    }

    static <T> Stream<T> of(T var0) {
        return StreamSupport.stream(new StreamBuilderImpl(var0), false);
    }

    @SafeVarargs
    static <T> Stream<T> of(T... var0) {
        return Arrays.stream(var0);
    }

    static <T> Stream<T> iterate(final T var0, final UnaryOperator<T> var1) {
        Objects.requireNonNull(var1);
        Iterator var2 = new Iterator<T>() {
            T t;

            {
                this.t = Streams.NONE;
            }

            public boolean hasNext() {
                return true;
            }

            public T next() {
                return this.t = this.t == Streams.NONE ? var0 : var1.apply(this.t);
            }
        };
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(var2, 1040), false);
    }

    static <T> Stream<T> generate(Supplier<T> var0) {
        Objects.requireNonNull(var0);
        return StreamSupport.stream(new OfRef(9223372036854775807L, var0), false);
    }

    static <T> Stream<T> concat(Stream<? extends T> var0, Stream<? extends T> var1) {
        Objects.requireNonNull(var0);
        Objects.requireNonNull(var1);
        java.util.stream.Streams.ConcatSpliterator.OfRef var2 = new java.util.stream.Streams.ConcatSpliterator.OfRef(var0.spliterator(), var1.spliterator());
        Stream var3 = StreamSupport.stream(var2, var0.isParallel() || var1.isParallel());
        return (Stream)var3.onClose(Streams.composedClose(var0, var1));
    }

    public interface Builder<T> extends Consumer<T> {
        void accept(T var1);

        default Stream.Builder<T> add(T var1) {
            this.accept(var1);
            return this;
        }

        Stream<T> build();
    }
```

#### Stream操作的三个步骤

**一、创建Stream**

从一个数据源，如集合、数组中获取流。

**二、中间操作**

一个操作的中间链，对数据源的数据进行操作。

**三、终止操作**

一个终止操作，执行中间操作链，并产生结果。

#### 创建Stream的四种方式

1.数组：使用Arrays中的静态方法stream()获取数组流

```java
// 1.通过Arrays中的静态方法stream()获取数组流
Employee[] emps = new Employee[10];
Stream<Employee> ArraysStream = Arrays.stream(emps);
```

2.集合：通过Collection得Stream（）方法（串行流）或者 parallelStream（）方法（并行流）创建Stream

```java
// 2.通过Collection系列集合提供的stream()或parallelStream|()
List<String> list = new ArrayList<>();
Stream<String> stringStream = list.stream();
Stream<String> stringParallelStream = list.parallelStream();
```

3.通过Stream类中得 of（）静态方法获取流

```java
// 3.通过Stream类中的静态方法of()
Stream<String> stream = Stream.of("aa", "bb", "cc");
```

4.创建无限流：Stream.iterate（迭代）、Stream.generate（生成)

```java
// 4.创建无限流
//  4.1迭代（需要传入一个种子，也就是起始值，然后传入一个一元操作）
Stream<Integer> integerStream = Stream.iterate(2, (x) -> x * 2);
//  4.2生成(无限产生对象)
Stream<Double> doubleStream = Stream.generate(() -> Math.random());
```

#### Stream中间操作（流水线式中间操作）

多个中间操作可以连接起来形成一个流水线，除非流水线终止操作，否则中间操作不会执行任何处理。
终止操作时一次性全部处理，称为“延迟加载”。

##### 筛选与切片

**常用方法：**

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| filter   | filter 方法用于通过设置的条件过滤出元素。                    |
| limit    | limit 方法用于获取指定数量的流。                             |
| skip     | 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补。 |
| distinct | 筛选，通过流所生成元素的hashCode()和equals()去除重复元素。   |

```java
//1.filter 方法用于通过设置的条件过滤出元素
Stream<Employee> stream = emps.stream().filter(employee -> {
    System.out.println("中间操作延迟加载");
    return employee.getAge() > 18;
});
// 终止操作：除非流水线终止操作，否则中间操作不会执行任何处理
// 内部迭代，将迭代交给JDK
stream.forEach(System.out::println);
```

```java
// limit-截断流 方法用于获取指定数量的流。
// 迭代两次，终止迭代
emps.stream().filter(employee -> {
    System.out.println("短路");
    return employee.getAge() > 8;
}).limit(2).forEach(System.out::println);
```

```java
//跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补。
emps.stream().skip(2).forEach(System.out::println);
```

```java
//筛选，去除重复元素。（引用类型通过流所生成元素的hashCode()和equals()）
emps.stream().distinct().forEach(System.out::println);
```

##### 映射（创建一个新的Stream）

**常用方法：**

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| map     | map - 接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上 |
| flatMap | 接收一个函数作为参数，将流中的每个值都转换成另一个流，然后把所有的流连接成“一个流”。（类似集合的addAll()方法） |

```java
// 将雇员List的雇员名映射一个新元素(Stream)
Stream<String> nameStream = emps.stream().map(Employee::getName);
nameStream.forEach(System.out::println);
```

```java
/**
  * 将字符串的每一个字符映射成一个流
  */
public static Stream<Character> filterCharacter(String str){
    List<Character> list = new ArrayList<>();
    for (Character ch : str.toCharArray()){
        list.add(ch);
   	}
    return list.stream();
}
// 如果映射的是流对象,map映射的是这个流对象，而flatMap映射的是流对象里面的每一个元素。类似add和addAll的区别
List<String> list = Arrays.asList("aaa", "bbb", "ccc", "ddd");
Stream<Stream<Character>> streamStream = list.stream().map(TestStream::filterCharacter);
streamStream.forEach(System.out::println);
//java.util.stream.ReferencePipeline$Head@12bb4df8
//java.util.stream.ReferencePipeline$Head@4cc77c2e
//java.util.stream.ReferencePipeline$Head@7a7b0070
//java.util.stream.ReferencePipeline$Head@39a054a5
```

通过打印可知，如果想遍历流中的每一个字符，还需多一步遍历

```java
List<String> list = Arrays.asList("aaa", "bbb", "ccc", "ddd");
Stream<Stream<Character>> streamStream = list.stream().map(TestStream::filterCharacter);
streamStream.forEach(characterStream -> characterStream.forEach(System.out::println));
//a
//a
//...
//d
```

而flatMap方法的核心是先映射每个元素，然后进行操作，然后进行扁平化处理，最后汇集所有进行扁平化处理的结果集形成一个新的列表（扁平化：简而言之就是去除所有的修饰）。上面实例使用flatMap可以简化为:

```java
List<String> list = Arrays.asList("aaa", "bbb", "ccc", "ddd");
Stream<Character> characterStream = list.stream().flatMap(TestStream::filterCharacter);
characterStream.forEach(System.out::println);
```

对于数值型的流，可以使用mapToInt、mapToLong、mapToDouble、flatMapToInt、flatMapToLong、flatMapToDouble相关的映射方法，简化操作。

##### 排序

| 方法                                | 描述                                                    |
| ----------------------------------- | ------------------------------------------------------- |
| sorted（）                          | 自然排序，调用元素类重写的Comparable接口的compareTo方法 |
| sorted(Comparator<? super T> var1); | 定制排序，接收一个Comparator接口，自己实现排序规则      |

```java
List<String> list = Arrays.asList("zzz","aaa", "bbb", "ddd", "ccc");
list.stream().sorted().forEach(System.out::print);
```
</div>